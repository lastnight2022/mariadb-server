SET sql_mode=ORACLE;
#
# Error: Unknown cursor and wrong variable data type in OPEN, FETCH, CLOSE
#
BEGIN
OPEN c FOR SELECT 1 AS c FROM DUAL
END;
$$
ERROR 42000: Undeclared variable: c
DECLARE
c INT;
BEGIN
OPEN c FOR SELECT 1 AS c FROM DUAL;
END;
$$
ERROR HY000: Illegal parameter data type int for operation 'OPEN'
DECLARE
c INT;
BEGIN
CLOSE c;
END;
$$
ERROR HY000: Illegal parameter data type int for operation 'CLOSE'
DECLARE
a INT;
c INT;
BEGIN
FETCH c INTO a;
END;
$$
ERROR HY000: Illegal parameter data type int for operation 'FETCH'
#
# Error: Closing a not opened cursor
#
DECLARE
c SYS_REFCURSOR;
BEGIN
CLOSE c;
END;
$$
ERROR 24000: Cursor is not open
#
# Error: Fetching from a not opened cursor
#
DECLARE
a INT;
c SYS_REFCURSOR;
BEGIN
FETCH c INTO a;
END;
$$
ERROR 24000: Cursor is not open
#
# Error: fetching beyond the available number of records
# sql_mode=ORACLE preserved the variable value
#
DECLARE
a INT;
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT 1 FROM DUAL;
FETCH c INTO a;
SELECT a;
FETCH c INTO a;
SELECT a;
END;
$$
a
1
a
1
CREATE OR REPLACE FUNCTION f1 RETURN SYS_REFCURSOR IS
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT 1 AS a FROM DUAL;
RETURN c;
END;
$$
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
FOR i IN 1..10000
LOOP
c:= f1();
FETCH c INTO a;
END LOOP;
END;
$$
ERROR HY000: Too many open cursors; max 30 cursors allowed
DROP FUNCTION f1;
#
# Two consequent OPEN (without a CLOSE in beetween) are allowed
#
DECLARE
a INT;
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT 1 FROM DUAL;
OPEN c FOR SELECT 2 FROM DUAL;
FETCH c INTO a;
SELECT a;
END;
$$
a
2
#
# Simple use example (OPEN, FETCH, CLOSE)
#
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
OPEN c FOR SELECT 1 FROM DUAL;
FETCH c INTO a;
CLOSE c;
SELECT a;
END;
$$
a
1
#
# Fetching from two parallel cursors
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1);
CREATE PROCEDURE p1() AS
a0 INT;
a1 INT;
c0 SYS_REFCURSOR;
c1 SYS_REFCURSOR;
BEGIN
OPEN c0  FOR SELECT a*10 FROM t1;
OPEN c1  FOR SELECT a*20 FROM t1;
FETCH c0 INTO a0;
FETCH c1 INTO a1;
SELECT a0, a1;
CLOSE c0;
CLOSE c1;
END;
$$
CALL p1;
a0	a1
10	20
DROP PROCEDURE p1;
DROP TABLE t1;
#
# Many consequent OPEN (without a CLOSE in between) are allowed
# and do not cause ER_TOO_MANY_OPEN_CURSORS.
#
DECLARE
c SYS_REFCURSOR;
BEGIN
FOR i IN 0..300
LOOP
OPEN c FOR SELECT 1 AS c FROM DUAL;
END LOOP;
END;
$$
#
# SYS_REFCURSOR alasing
#
DECLARE
c0 SYS_REFCURSOR;
c1 SYS_REFCURSOR;
a INT;
BEGIN
OPEN c0 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
c1:= c0;
FETCH c0 INTO a;
SELECT a;
OPEN c0 FOR SELECT 21 FROM DUAL UNION SELECT 22 FROM DUAL;
FETCH c1 INTO a; /* c1 now points to the new "OPEN c0" */
SELECT a;
END;
$$
a
11
a
21
#
# Function returning SYS_REFCURSOR and mysql.proc
#
CREATE FUNCTION f1() RETURN SYS_REFCURSOR AS
c0 SYS_REFCURSOR;
BEGIN
RETURN c0;
END;
$$
SELECT returns FROM mysql.proc WHERE name='f1';
returns
sys_refcursor
SHOW CREATE FUNCTION f1;
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
f1	PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ORACLE,NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS,NO_AUTO_CREATE_USER,SIMULTANEOUS_ASSIGNMENT	CREATE DEFINER="root"@"localhost" FUNCTION "f1"() RETURN sys_refcursor
AS
c0 SYS_REFCURSOR;
BEGIN
RETURN c0;
END	latin1	latin1_swedish_ci	latin1_swedish_ci
DROP FUNCTION f1;
#
# Procedure with a SYS_REFCURSOR parameter and mysql.proc
#
CREATE PROCEDURE p1(a0 OUT SYS_REFCURSOR) AS
c0 SYS_REFCURSOR;
BEGIN
a0:= c0;
END;
$$
SELECT param_list FROM mysql.proc WHERE name='p1';
param_list
a0 OUT SYS_REFCURSOR
SHOW CREATE PROCEDURE p1;
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
p1	PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ORACLE,NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS,NO_AUTO_CREATE_USER,SIMULTANEOUS_ASSIGNMENT	CREATE DEFINER="root"@"localhost" PROCEDURE "p1"(a0 OUT SYS_REFCURSOR)
AS
c0 SYS_REFCURSOR;
BEGIN
a0:= c0;
END	latin1	latin1_swedish_ci	latin1_swedish_ci
DROP PROCEDURE p1;
#
# Returning a opened cursor from a function
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (10),(20);
CREATE FUNCTION f1 RETURN SYS_REFCURSOR AS
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT a FROM t1 ORDER BY a;
RETURN c;
END;
$$
CREATE PROCEDURE p1 AS
a INT;
c SYS_REFCURSOR DEFAULT f1();
BEGIN
LOOP
FETCH c INTO a;
EXIT WHEN c%NOTFOUND;
SELECT a;
END LOOP;
CLOSE c;
END;
$$
CALL p1;
a
10
a
20
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
#
# Returning an opened cursor as an OUT param
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (10);
INSERT INTO t1 VALUES (20);
CREATE PROCEDURE p1(c OUT SYS_REFCURSOR) AS
BEGIN
OPEN c FOR SELECT a FROM t1 ORDER BY a;
END;
$$
CREATE PROCEDURE p2 AS
a INT;
c SYS_REFCURSOR;
BEGIN
p1(c);
LOOP
FETCH c INTO a;
EXIT WHEN c%NOTFOUND;
SELECT a;
END LOOP;
CLOSE c;
END;
$$
CALL p2;
a
10
a
20
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP TABLE t1;
#
# Cursor attributes on an opened SYS_REFCURSOR
#
DECLARE
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT 1;
SELECT c%ISOPEN;
END;
$$
c%ISOPEN
1
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
OPEN c FOR SELECT 1;
SELECT c%FOUND;
FETCH c INTO a;
SELECT c%FOUND;
FETCH c INTO a;
SELECT c%FOUND;
END;
$$
c%FOUND
NULL
c%FOUND
1
c%FOUND
0
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
OPEN c FOR SELECT 1;
SELECT c%NOTFOUND;
FETCH c INTO a;
SELECT c%NOTFOUND;
FETCH c INTO a;
SELECT c%NOTFOUND;
END;
$$
c%NOTFOUND
NULL
c%NOTFOUND
0
c%NOTFOUND
1
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
OPEN c FOR SELECT 1;
SELECT c%ROWCOUNT;
FETCH c INTO a;
SELECT c%ROWCOUNT;
FETCH c INTO a;
SELECT c%ROWCOUNT;
END;
$$
c%ROWCOUNT
0
c%ROWCOUNT
1
c%ROWCOUNT
1
#
# Returning an opened cursor from a function
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (10),(20),(30);
CREATE FUNCTION f1 RETURN SYS_REFCURSOR
AS
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT * FROM t1;
RETURN c;
END;
$$
DECLARE
c SYS_REFCURSOR;
a INT;
BEGIN
c := f1();
LOOP 
FETCH c into a;
EXIT WHEN c%NOTFOUND;
SELECT a;
END LOOP;
END;
$$
a
10
a
20
a
30
DROP FUNCTION f1;
DROP TABLE t1;
